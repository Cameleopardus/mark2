#!/usr/bin/python
from twisted.internet import reactor

usage_text = "usage: mark2 [options] command ..."

help_text = """
mark2 is a minecraft server wrapper

{usage}

commands:
  start     [path]    start a server
  list                list running servers
  attach              attach to a server
  stop                stop mark2
  kill                kill mark2
  send      input...  send a console command
  jar-list            list server jars
  jar-get   name      download a server jar

flags:
  -h  --help       display this message
  -i  --immediate  don't wait for server output (only affects start, stop and kill)

options:
  -b  --base       the directory to put mark2-related temp files (default: /tmp/mark2)
                   does not apply to 'jar-list' or 'jar-get'
  -n  --name       choose this named server (useful if you run more than one)
                   does not apply to 'list', 'jar-list' or 'jar-get'

examples:
  mark2 start /home/you/mcservers/pvp
  mark2 attach -n pvp
  mark2 send -n pvp say hello!
  mark2 stop -i -n pvp
""".format(usage=usage_text)

import os
import sys
import glob
import stat
import time

#start:
import subprocess

#attach:
import user_client

#stop/kill
import signal
import errno

#send
import json
import socket

#jar-list/jar-get
import servers

class Mark2Error(Exception):
    def __init__(self, error):
        self.error = error

    def __str__(self):
        return "error: %s" % self.error

class Mark2ParseError(Mark2Error):
    def __str__(self):
        return "%s\nparse error: %s" % (usage_text, self.error)


def make_writable(directory):
    need_modes = stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH | stat.S_IRWXG | stat.S_IRWXO
    good_modes = stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO | stat.S_ISVTX

    if not os.path.exists(directory):
        os.makedirs(directory, good_modes)

    st = os.stat(directory)
    if (st.st_mode & need_modes) == need_modes:
        return True

    try:
        os.chmod(directory, good_modes)
        return True
    except Exception:
        raise Mark2Error('{} does not have the necessary modes to run mark2 and I do not have\npermission to change them!'.format(directory))

def check_config():
    path_old = 'resources/mark2.default.properties'
    path_new = 'config/mark2.properties'

    if not os.path.exists(path_new):
        make_writable('config')
        file_old = open(path_old, 'r')
        file_new = open(path_new, 'w')

        l = ''
        while l.strip() == '' or l.startswith('### ###'):
            l = file_old.readline()

        while l != '':
            file_new.write(l)
            l = file_old.readline()

        file_old.close()
        file_new.close()

        print 'I\'ve created a default configuration file at {}'.format(path_new)
        response = raw_input('Would you like to edit it now? [yes]') or 'yes'
        if response == 'yes':
            try:
                subprocess.call(['sensible-editor', path_new])
            except Exception:
                raise Mark2Error('couldn\'t start editor')

class Skeleton:
    def __init__(self, shared_path, server_name=None, server_path=None, jar_file=None):
        self.shared_path = shared_path

        self.servers = self.get_servers()

        if server_name:
            self.server_name = server_name
        else:
            if len(self.servers) > 0:
                self.server_name = self.servers[0]
            else:
                raise Mark2Error("no servers running!")

        self.server_path = server_path
        self.jar_file    = jar_file

    def shared(self, ty, name=None):
        if name is None:
            name = self.server_name

        return os.path.join(self.shared_path, "%s.%s" % (name, ty))

    def get_servers(self):
        o = []
        for path in glob.glob(self.shared('pid', '*')):
            with open(path) as fp:
                pid = int(fp.read())
                try:
                    os.kill(pid, 0)
                except OSError as err:
                    if err.errno == errno.ESRCH:
                        os.remove(path)
                        continue
            f = os.path.basename(path)
            f = os.path.splitext(f)[0]
            o.append(f)

        return sorted(o)

    def is_running(self):
        return self.server_name in self.servers

    def kill(self, sig):
        f = open(self.shared('pid'), 'r')
        pid = int(f.read())
        f.close()
        os.kill(pid, sig)

    def wait(self, *tokens):
        with open(self.shared('log'), 'r') as f:
            f.seek(0,2)
            while True:
                line = f.readline().rstrip()
                if not line:
                    time.sleep(0.1)
                    continue

                if line[0] in (" ", "\t"):
                    print line
                    continue

                line = line.split(" ", 3)
                if line[2] == '[mark2]':
                    print line[3]
                    line = line[3].split(" ", 2)
                    for t in tokens:
                        if line[2].startswith(t):
                            return


    def do_start(self):
        #clear remnants
        open(self.shared('log'), 'w').close()
        if os.path.exists(self.shared('sock')):
            os.remove(self.shared('sock'))

        #build command
        command = [
                'twistd',
                '--pidfile', self.shared('pid'),
                '--logfile', self.shared('log'),
                'mark2',
                '--shared-path', self.shared_path,
                '--server-name', os.path.basename(self.server_name),
                '--server-path', self.server_path]

        if self.jar_file:
            command += ['--jar-file', self.jar_file]

        subprocess.Popen(command, close_fds=True)

    def do_list(self):
        for server in self.servers:
            print server

    def do_attach(self):
        user_client.UserFactory(self.shared_path, self.server_name)

    def do_stop(self):
        #self.kill(signal.SIGINT)
        self.do_send('~stop')

    def do_kill(self):
        #self.kill(signal.SIGKILL)
        self.do_send('~kill')

    def do_send(self, data):
        d = {
            'type': 'input',
            'user': '@external',
            'line': data
        }
        d = json.dumps(d) + "\n"

        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        s.connect(self.shared('sock'))
        s.send(d)
        s.close()

def main():
    immediate   = False
    shared_path = '/tmp/mark2'
    script_path = sys.path[0]
    server_name = None
    command = None

    args = sys.argv[1:]

    while len(args) > 0:
        if args[0].startswith('-'):
            a = args.pop(0)
            if a in ('-h', '--help'):
                print help_text
                return
            elif a in ('-i', '--immediate'):
                immediate = True
            elif a in ('-b', '--base'):
                shared_path = args.pop(0)
            elif a in ('-n', '--name'):
                server_name = args.pop(0)
            else:
                raise Mark2ParseError("unknown flag: " + a)
        elif not command:
            command = args.pop(0)
        else:
            break

    if command is None:
        raise Mark2ParseError('missing command!')

    #check shared dir
    make_writable(shared_path)

    if command == 'start':
        #get server path
        if len(args) == 0:
            server_path = ""
        elif len(args) == 1:
            server_path = args[0]
        else:
            raise Mark2ParseError("unknown token after server path: " + " ".join(args[1:]))
        server_path = os.path.abspath(server_path)

        #check path exists and parse a path to a .jar
        jar_file = None
        if os.path.isdir(server_path):
            pass
        elif os.path.isfile(server_path):
            if server_path.endswith('.jar'):
                server_path, jar_file = os.path.split(server_path)
            else:
                raise Mark2Error("unknown file type: " + server_path)
        else:
            raise Mark2Error("path does not exist: " + server_path)

        #get server name
        if server_name is None:
            server_name = os.path.basename(server_path)

        # move to the directory this script is in
        os.chdir(script_path)

        # check we've got config/mark2.properties
        check_config()

        skel = Skeleton(shared_path, server_name, server_path, jar_file)
        if skel.is_running():
            raise Mark2Error("server already running: " + server_name)
        skel.do_start()

        if not immediate:
            skel.wait('# mark2 started.', '# mark2 stopped.')

    elif command == 'list':
        if len(args) > 0:
            raise Mark2ParseError("unknown token: " + " ".join(args))
        skel = Skeleton(shared_path)
        skel.do_list()

    elif command == 'attach':
        if len(args) > 0:
            raise Mark2ParseError("unknown token: " + " ".join(args))
        skel = Skeleton(shared_path, server_name)
        if not skel.is_running():
            raise Mark2Error("server not running: " + server_name)
        skel.do_attach()
    elif command == 'stop':
        if len(args) > 0:
            raise Mark2ParseError("unknown token: " + " ".join(args))
        skel = Skeleton(shared_path, server_name)
        if not skel.is_running():
            raise Mark2Error("server not running: " + server_name)
        skel.do_stop()
        if not immediate:
            skel.wait('# mark2 stopped.')
    elif command == 'kill':
        if len(args) > 0:
            raise Mark2ParseError("unknown token: " + " ".join(args))
        skel = Skeleton(shared_path, server_name)
        if not skel.is_running():
            raise Mark2Error("server not running: " + server_name)
        skel.do_kill()
        if not immediate:
            skel.wait('# mark2 stopped.')
    elif command == 'send':
        if len(args) == 0:
            raise Mark2ParseError("nothing to send!")
        skel = Skeleton(shared_path, server_name)
        if not skel.is_running():
            raise Mark2Error("server not running: " + server_name)
        skel.do_send(" ".join(args))
    elif command == 'jar-list':
        if len(args) > 0:
            raise Mark2ParseError("unknown token: " + " ".join(args))

        def err(what):
            reactor.stop()
            print "error: %s" % what.value

        def handle(listing):
            reactor.stop()
            if len(listing) == 0:
                print "error: no server jars found!"
            else:
                print "The following server jars/zips are available:"
                print listing

        d = servers.jar_list()
        d.addCallbacks(handle, err)
        reactor.run()
    elif command == 'jar-get':
        if len(args) == 0:
            raise Mark2ParseError("missing jar type!")
        elif len(args) == 1:
            name = args[0]
        else:
            raise Mark2ParseError("unknown token after jar type: " + " ".join(args[1:]))

        def err(what):
            reactor.stop()
            print "error: %s" % what.value

        def handle((filename, data)):
            reactor.stop()
            if os.path.exists(filename):
                print "error: %s already exists!" % filename
            else:
                f = open(filename, 'wb')
                f.write(data)
                f.close()
                print "success! saved as %s" % filename

        d = servers.jar_get(name)
        d.addCallbacks(handle, err)
        reactor.run()
    else:
        raise Mark2ParseError("unknown command: " + command)

if __name__ == '__main__':
    try:
        main()
    except Mark2Error, e:
        print e
