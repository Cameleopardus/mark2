#!/usr/bin/python

'''
mark2

The main entry point for mark2. It performs housekeeping and, depending on
how it is invoked, will also run the client or invoke `twistd` to run the
server.
'''

from clize import clize, run
import os
import os.path
import shutil
import signal
import stat
import subprocess
import sys

import aclient
import properties


SOCKET_BASE = '/tmp/mcpitch/'


class Mark2Error(Exception):
    error = ''

    def __init__(self, error):
        self.error = error

    def __str__(self):
        return self.error


def ensure_basedir(dir, need_write=False):
    need_modes = stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH
    if need_write:
        need_modes |= stat.S_IRWXG | stat.S_IRWXO
    good_modes = stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO | stat.S_ISVTX
    
    if not os.path.exists(dir):
        os.makedirs(dir, good_modes)
    
    st = os.stat(dir)
    if (st.st_mode & need_modes) == need_modes:
        return True
    
    try:
        os.chmod(dir, good_modes)
        return True
    except Exception:
        raise Mark2Error('{} does not have the necessary modes to run mark2 and I do not have\npermission to change them!'.format(dir))


def check_properties(server=None, quiet=False):
    path = os.path.join(sys.path[0], 'resources', 'mark2.properties')
    default_path = os.path.join(sys.path[0], 'resources', 'mark2.default.properties')
    if server:
        server = os.path.join(server, 'mark2.properties')
    
    prop = properties.Properties(default_path)
    del prop["havent_read_conf"]
    
    if not os.path.exists(path):
        shutil.copy(default_path, path)
    
    prop = properties.Properties(path, prop)
    
    if server and os.path.exists(server):
        prop = properties.Properties(server, prop)
    
    if prop.get('havent_read_conf', None) and not quiet:
        print 'Your config file at {} requires attention.'.format(path)
        editor = raw_input('Do you want to edit it now [yes]? ') or 'yes'
        while editor not in ['yes', 'no']:
            editor = raw_input('Enter \'yes\' or \'no\' [yes]: ') or 'yes'
        if editor == 'yes':
            subprocess.call(['sensible-editor', path])
    

@clize(alias={'quiet': ('q',)})
def start(quiet=False, *path):
    '''
    Start a mark2 server.
    
    path: path to the server to run
    
    quiet: don't show non-error output or ask for input from the user
    '''
    # let twistd run our our server
    
    # first make sure we can properly run
    ensure_basedir(SOCKET_BASE, need_write=True)
    
    # we need the path to pass to twistd as absolute
    path = os.path.abspath(' '.join(path))
    
    # target has to at least exist
    if not os.path.exists(path):
        raise Mark2Error('{} does not exist.'.format(path))
    
    # if it's a file and its extension is .jar, take the directory as the path
    # and tell mark2 to use its name as the jarfile
    if os.path.isfile(path):
        if os.path.splitext(path)[1] != '.jar':
            raise Mark2Error('{} is not a directory or jarfile'.format(path))
        path, jarfile = os.path.split(path)
    else:
        jarfile = None
    
    # move to the directory this script is in
    os.chdir(sys.path[0])
    
    # create mark2.properties if it's not there and give the user the option to edit it if it's
    # invalid
    check_properties(path, quiet=quiet)
    
    # set up options for twistd
    pidfile = os.path.join(path, 'mark2.pid')
    logfile = os.path.join(path, 'mark2.log')
    twistd_options = ['--pidfile', pidfile, '--logfile', logfile]
    mark2_options = ['--sockets', SOCKET_BASE]
    if path:
        mark2_options += ['--dir', path]
    if jarfile:
        mark2_options += ['--jarfile', jarfile]
    
    # if we're not being quiet, we need a pipe to watch output
    if not quiet:
        r, w = os.pipe()
        mark2_options += ['--fd', str(w)]
    
    # we don't want to listen to twistd
    dev_null = open('/dev/null', 'w')
    
    # run!
    subprocess.call(['twistd'] + twistd_options + ['mark2'] + mark2_options, stdout=dev_null)
    
    # if --quiet was specified, shut up now, otherwise write output
    if not quiet:
        # close our copy of the write end of the pipe
        os.close(w)
        
        # write output
        while True:
            read = os.read(r, 512)
            if not read:
                break
            sys.stdout.write(read)


@clize(alias={'hard': ('h',)})
def kill(hard=False, *path):
    '''
    Stop a mark2 server.
    
    path: path to the server to kill
    
    hard: use SIGKILL instead of SIGINT (not recommended)
    '''
    # send SIGINT to the twistd running at a given path
    path = os.path.abspath(' '.join(path))
    
    pidfile = os.path.join(path, 'mark2.pid')
    if not os.path.exists(path):
        raise Mark2Error('Invalid path specified.')
    elif not os.path.exists(pidfile):
        raise Mark2Error('Server is not running.')
    try:
        with open(pidfile, 'r') as f:
            pid = int(f.readline())
    except IOError:
        raise Mark2Error('Can\'t read {}.'.format(pidfile))
        return
    except ValueError:
        raise Mark2Error('Invalid pidfile: {}.'.format(pidfile))
    try:
        os.kill(pid, signal.SIGKILL if hard else signal.SIGINT)
        print 'Server at {} terminated.'.format(path)
    except OSError:
        raise Mark2Error('Failed to signal process {}, is the server running?.'.format(pid))


@clize
def attach(*path):
    '''
    Open a mark2 client and attach it to a server.
    
    server: name of the server to attach to. If not specified mark2 will
    choose the first server alphabetically.
    '''
    # first make sure we can properly run
    ensure_basedir(SOCKET_BASE, need_write=False)
    
    # run the client in our own context, why not
    return aclient.main(SOCKET_BASE, ' '.join(path))

# never mind how someone managed to import this, stop them
if __name__ != '__main__':
    print "You're doing it wrong."
    sys.exit(1)

try:
    sys.argv[0] = os.path.basename(sys.argv[0])
    run((start, kill, attach))
except Mark2Error as e:
    print 'Failed: {}'.format(e)
