#!/usr/bin/python

'''
mark2

The main entry point for mark2. It performs housekeeping and, depending on
how it is invoked, will also run the client or invoke `twistd` to run the
server.
'''

import os
import os.path
import shutil
import signal
import stat
import subprocess
import sys

import aclient
import properties


SOCKET_BASE = '/tmp/mcpitch/'


class Mark2Error(Exception):
    error = ''

    def __init__(self, error):
        self.error = error

    def __str__(self):
        return self.error


def ensure_basedir(dir, need_write=False):
    need_modes = stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH
    if need_write:
        need_modes |= stat.S_IRWXG | stat.S_IRWXO
    good_modes = stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO | stat.S_ISVTX
    
    if not os.path.exists(dir):
        os.makedirs(dir, good_modes)
    
    st = os.stat(dir)
    if (st.st_mode & need_modes) == need_modes:
        return True
    
    try:
        os.chmod(dir, good_modes)
        return True
    except Exception:
        raise Mark2Error('{} does not have the necessary modes to run mark2 and I do not have\npermission to change them!'.format(dir))


def check_properties(server=None):
    path = os.path.join(sys.path[0], 'resources', 'mark2.properties')
    default_path = os.path.join(sys.path[0], 'resources', 'mark2.default.properties')
    if server:
        server = os.path.join(server, 'mark2.properties')
    
    prop = properties.Properties(default_path)
    del prop["havent_read_conf"]
    
    if not os.path.exists(path):
        shutil.copy(default_path, path)
    
    prop = properties.Properties(path, prop)
    
    if server and os.path.exists(server):
        prop = properties.Properties(server, prop)
    
    if prop.get('havent_read_conf', None):
        print 'Your config file at {} requires attention.'.format(path)
        editor = raw_input('Do you want to edit it now [yes]? ') or 'yes'
        while editor not in ['yes', 'no']:
            editor = raw_input('Enter \'yes\' or \'no\' [yes]: ') or 'yes'
        if editor == 'yes':
            subprocess.call(['sensible-editor', path])
    

def run_server(*args):
    # let twistd run our our server
    
    # first make sure we can properly run
    ensure_basedir(SOCKET_BASE, need_write=True)
    
    # we need the path to pass to twistd as absolute
    path = os.path.abspath(' '.join(args) if args else '')
    
    # target has to at least exist
    if not os.path.exists(path):
        raise Mark2Error('{} does not exist.'.format(path))
    
    # if it's a file and its extension is .jar, take the directory as the path
    # and tell mark2 to use its name as the jarfile
    if os.path.isfile(path):
        if os.path.splitext(path)[1] != '.jar':
            raise Mark2Error('{} is not a directory or jarfile'.format(path))
        path, jarfile = os.path.split(path)
    else:
        jarfile = None
    
    # move to the directory this script is in
    os.chdir(sys.path[0])
    
    # create mark2.properties if it's not there and give the user the option to edit it if it's
    # invalid
    check_properties(path)
    
    # look at output
    r, w = os.pipe()
    
    # set up options for twistd
    pidfile = os.path.join(path, 'mark2.pid')
    logfile = os.path.join(path, 'mark2.log')
    twistd_options = ['--pidfile', pidfile, '--logfile', logfile]
    mark2_options = ['--fd', str(w), '--sockets', SOCKET_BASE]
    if path:
        mark2_options += ['--dir', path]
    if jarfile:
        mark2_options += ['--jarfile', jarfile]
    
    # run!
    subprocess.call(['twistd'] + twistd_options + ['mark2'] + mark2_options)
    
    # close our copy of the write end of the pipe
    os.close(w)
    
    # write output
    while True:
        read = os.read(r, 512)
        if not read:
            break
        sys.stdout.write(read)


def kill_server(*args):
    # send SIGINT to the twistd running at a given path
    path = os.path.abspath(' '.join(args) if args else '.')
    pidfile = os.path.join(path, 'mark2.pid')
    if not os.path.exists(path):
        raise Mark2Error('Invalid path specified.')
    elif not os.path.exists(pidfile):
        raise Mark2Error('Server is not running.')
    try:
        with open(pidfile, 'r') as f:
            pid = int(f.readline())
    except IOError:
        raise Mark2Error('Can\'t read {}.'.format(pidfile))
        return
    except ValueError:
        raise Mark2Error('Invalid pidfile: {}.'.format(pidfile))
    try:
        os.kill(pid, signal.SIGINT)
        print 'Server at {} terminated.'.format(path)
    except OSError:
        raise Mark2Error('Failed to signal process {}, is the server running?.'.format(pid))


def run_client(use_server=None):
    # first make sure we can properly run
    ensure_basedir(SOCKET_BASE, need_write=False)
    
    # run the client in our own context, why not
    return aclient.main(SOCKET_BASE, use_server)

# never mind how someone managed to import this, stop them
if __name__ != '__main__':
    print "You're doing it wrong."
    sys.exit(1)

# process arguments
if len(sys.argv) >= 2:
    command = sys.argv[1]
    args = sys.argv[2:]
else:
    command = ''
    args = []


def main(command, args):
    try:
        if command == 'attach':
            run_client(*args)
        elif command == 'start':
            run_server(*args)
        elif command == 'kill':
            kill_server(*args)
        else:
            print '''
mark2 start  path/to/server
mark2 kill   path/to/server
mark2 attach server
'''
    except Mark2Error as e:
        print 'Failed to {}: {}'.format(command, e)

main(command.lower(), args)
