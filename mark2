#!/usr/bin/python

'''
mark2

The main entry point for mark2. It performs housekeeping and, depending on
how it is invoked, will also run the client or invoke `twistd` to run the
server.
'''

from clize import clize, run
import os
import signal
import stat
import subprocess
import sys
import errno

import user_client


SOCKET_BASE = '/tmp/mark2/'


class Mark2Error(Exception):
    error = ''

    def __init__(self, error):
        self.error = error

    def __str__(self):
        return self.error


def ensure_basedir(directory, need_write=False):
    need_modes = stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH
    if need_write:
        need_modes |= stat.S_IRWXG | stat.S_IRWXO
    good_modes = stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO | stat.S_ISVTX
    
    if not os.path.exists(directory):
        os.makedirs(directory, good_modes)
    
    st = os.stat(directory)
    if (st.st_mode & need_modes) == need_modes:
        return True
    
    try:
        os.chmod(directory, good_modes)
        return True
    except Exception:
        raise Mark2Error('{} does not have the necessary modes to run mark2 and I do not have\npermission to change them!'.format(directory))


def check_config():
    path = lambda *a: os.path.join(sys.path[0], *a)
    
    path_old = path('resources', 'mark2.default.properties')
    path_new = path('config',    'mark2.properties')
    
    if not os.path.exists(path_new):
        ensure_basedir(path('config'), need_write=True)
        file_old = open(path_old, 'r')
        file_new = open(path_new, 'w')
        
        l = ''
        while l.strip() == '' or l.startswith('### ###'):
            l = file_old.readline()
        
        while l != '':
            file_new.write(l)
            l = file_old.readline()
        
        file_old.close()
        file_new.close()
            
        print 'I\'ve created a default configuration file at {}'.format(path_new)
        response = raw_input('Would you like to edit it now? [yes]') or 'yes'
        if response == 'yes':
            try:
                subprocess.call(['sensible-editor', path_new])
            except Exception:
                raise Mark2Error('Couldn\'t start editor')


@clize(alias={'quiet': ('q',)})
def start(quiet=False, *path):
    '''
    Start a mark2 server.
    
    path: path to the server to run
    '''
    # let twistd run our our server
    
    # first make sure we can properly run
    ensure_basedir(SOCKET_BASE, need_write=True)
    
    # we need the path to pass to twistd as absolute
    path = os.path.abspath(' '.join(path))
    
    # target has to at least exist
    if not os.path.exists(path):
        raise Mark2Error('{} does not exist.'.format(path))
    
    # if it's a file and its extension is .jar, take the directory as the path
    # and tell mark2 to use its name as the jarfile
    if os.path.isfile(path):
        if os.path.splitext(path)[1] != '.jar':
            raise Mark2Error('{} is not a directory or jarfile'.format(path))
        path, jarfile = os.path.split(path)
    else:
        jarfile = None
    
    # move to the directory this script is in
    os.chdir(sys.path[0])
    
    # check we've got config/mark2.properties
    check_config()
    
    # set up options for twistd
    pidfile = os.path.join(path, 'mark2.pid')
    logfile = os.path.join(path, 'mark2.log')
    twistd_options = ['--pidfile', pidfile, '--logfile', logfile]
    mark2_options = ['--sockets', SOCKET_BASE]
    if path:
        mark2_options += ['--dir', path]
    if jarfile:
        mark2_options += ['--jarfile', jarfile]
    
    # we need a pipe to watch output
    r, w = os.pipe()
    mark2_options += ['--fd', str(w)]
    
    # we don't want to listen to twistd
    dev_null = open('/dev/null', 'w')
    
    # print a helpful message
    if not quiet:
        print 'Server starting. Please wait...'
        
    # run!
    subprocess.call(['twistd'] + twistd_options + ['mark2'] + mark2_options, stdout=dev_null)
    
    # close our copy of the write end of the pipe
    os.close(w)
    
    # just exit now if we're in quiet mode
    if quiet:
        return
    
    # write output
    while True:
        read = os.read(r, 32)
        if not read:
            break
        sys.stdout.write(read)


#TODO: rewrite this
@clize(alias={'hard': ('h',)})
def kill(hard=False, *path):
    '''
    Stop a mark2 server.
    
    path: path to the server to kill
    
    hard: use SIGKILL instead of SIGINT (not recommended)
    '''
    # send SIGINT to the twistd running at a given path
    path = os.path.abspath(' '.join(path))
    
    pidfile = os.path.join(path, 'mark2.pid')
    if not os.path.exists(path):
        raise Mark2Error('Invalid path specified.')
    elif not os.path.exists(pidfile):
        raise Mark2Error('Server is not running.')
    try:
        with open(pidfile, 'r') as f:
            pid = int(f.readline())
    except IOError:
        raise Mark2Error('Can\'t read {}.'.format(pidfile))
        return
    except ValueError:
        raise Mark2Error('Invalid pidfile: {}.'.format(pidfile))
    try:
        os.kill(pid, signal.SIGKILL if hard else signal.SIGINT)
        #wait for it to finish
        while True:
            try:
                os.kill(pid, 0)
            except OSError as err:
                if err.errno == errno.ESRCH:
                    break
        print 'Server at {} terminated.'.format(path)
    except OSError:
        raise Mark2Error('Failed to signal process {}, is the server running?.'.format(pid))


@clize
def attach(*path):
    '''
    Open a mark2 client and attach it to a server.
    
    server: name of the server to attach to. If not specified mark2 will
    choose the first server alphabetically.
    '''
    # first make sure we can properly run
    ensure_basedir(SOCKET_BASE, need_write=False)
    
    # run the client in our own context, why not
    user_client.UserFactory(' '.join(path), SOCKET_BASE)

# never mind how someone managed to import this, stop them
if __name__ != '__main__':
    print 'You\'re doing it wrong.'
    sys.exit(1)

try:
    sys.argv[0] = os.path.basename(sys.argv[0])
    run((start, kill, attach))
except Mark2Error as e:
    print 'Failed: {}'.format(e)
